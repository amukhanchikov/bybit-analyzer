<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bybit Futures Analyzer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .loader {
            border: 5px solid #f3f3f3;
            border-top: 5px solid #3498db;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
        }
        .btn-loader {
            border: 2px solid #f3f3f3;
            border-top: 2px solid #3498db;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .timeframe-btn.selected, .nav-btn.selected {
            background-color: #2563eb; /* blue-700 */
            color: white;
        }
        .fade-up {
            opacity: 0;
            transform: translateY(15px);
            transition: opacity 0.4s ease-out, transform 0.4s ease-out;
        }
        .fade-up.visible {
            opacity: 1;
            transform: translateY(0);
        }
        #progress-bar-price, #progress-bar-volatility {
            transition: width 0.3s ease-out;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100">

    <div class="container mx-auto p-4 md:p-8">
        
        <header class="text-center mb-8">
            <h1 class="text-3xl md:text-4xl font-bold text-white mb-2">Bybit Futures Analyzer</h1>
            <p class="text-gray-400">Analyze the market with powerful tools</p>
        </header>
        
        <!-- Main Navigation -->
        <nav class="mb-6 flex justify-center">
            <div class="flex items-center gap-1 p-1 bg-gray-800 rounded-lg shadow-md">
                <button id="nav-price-analyzer" class="nav-btn selected bg-gray-700/50 hover:bg-gray-700 text-gray-300 font-semibold py-2 px-6 rounded-md transition duration-200">Price Analyzer</button>
                <button id="nav-volatility-analyzer" class="nav-btn bg-gray-700/50 hover:bg-gray-700 text-gray-300 font-semibold py-2 px-6 rounded-md transition duration-200">Volatility Analyzer</button>
            </div>
        </nav>

        <!-- PAGE: Price Analyzer -->
        <div id="price-analyzer-page">
            <div id="controls-price" class="bg-gray-800 p-5 rounded-lg shadow-lg mb-6 space-y-6"></div>
            <main id="content-area-price"></main>
        </div>

        <!-- PAGE: Volatility Analyzer -->
        <div id="volatility-analyzer-page" class="hidden">
            <div id="controls-volatility" class="bg-gray-800 p-5 rounded-lg shadow-lg mb-6 space-y-6"></div>
            <main id="content-area-volatility"></main>
        </div>
    </div>

    <script type="module">
        const Config = {
            API_BASE_URL: 'https://api.bybit.com',
            INSTRUMENTS_INFO_ENDPOINT: '/v5/market/instruments-info?category=linear',
            KLINE_ENDPOINT: '/v5/market/kline',
            TICKERS_ENDPOINT: '/v5/market/tickers'
        };

        const Utils = {
            sleep: ms => new Promise(resolve => setTimeout(resolve, ms)),
            getPlural: (value, unit) => `${Math.round(value)} ${Math.round(value) === 1 ? unit : unit + 's'}`,
            formatTimeframe: (totalHours) => {
                if (totalHours < 1) return Utils.getPlural(totalHours * 60, 'minute');
                if (totalHours < 24) return Utils.getPlural(totalHours, 'hour');
                return Utils.getPlural(totalHours / 24, 'day');
            },
            async processWithConcurrency(items, concurrencyLimit, processFn, progressCallback) {
                const results = [];
                const queue = [...items];
                let processedCount = 0;

                const executeTask = async () => {
                    while(queue.length > 0) {
                        const item = queue.shift();
                        if(item) {
                            try {
                                const result = await processFn(item);
                                if (result) {
                                    results.push(result);
                                }
                            } catch (e) {
                                console.error(`Error processing item ${item.symbol || item}:`, e);
                            } finally {
                                processedCount++;
                                if (progressCallback) {
                                    progressCallback(processedCount, items.length);
                                }
                            }
                        }
                    }
                };
                
                const workers = Array(concurrencyLimit).fill(null).map(() => executeTask());
                await Promise.all(workers);
                return results;
            }
        };

        const ApiService = {
            async fetchInstrumentsInfo() {
                let allInstruments = []; let cursor = ''; const limit = 1000;
                while (true) {
                    const url = `${Config.API_BASE_URL}${Config.INSTRUMENTS_INFO_ENDPOINT}&limit=${limit}${cursor ? `&cursor=${cursor}` : ''}`;
                    const response = await fetch(url);
                    if (!response.ok) throw new Error(`Bybit API Error: ${response.statusText}`);
                    const data = await response.json();
                    if (data.retCode !== 0) throw new Error(`Bybit API Response Error: ${data.retMsg}`);
                    allInstruments.push(...data.result.list.filter(item => item.status === 'Trading' && item.symbol.endsWith('USDT')).map(item => ({ symbol: item.symbol })));
                    cursor = data.result.nextPageCursor;
                    if (!cursor) break;
                }
                return allInstruments;
            },
            async fetchAllTickers() {
                const url = `${Config.API_BASE_URL}${Config.TICKERS_ENDPOINT}?category=linear`;
                const response = await fetch(url);
                if (!response.ok) throw new Error('Failed to fetch tickers');
                const data = await response.json();
                if(data.retCode !== 0) throw new Error(`Ticker API Error: ${data.retMsg}`);
                return data.result.list;
            },
            async fetchKlineData(symbol, time, interval) {
                const url = `${Config.API_BASE_URL}${Config.KLINE_ENDPOINT}?category=linear&symbol=${symbol}&interval=${interval}&start=${time}&limit=1`;
                const response = await fetch(url);
                if (!response.ok) return null;
                const data = await response.json();
                return (data.retCode === 0 && data.result.list.length > 0) ? data.result.list[0] : null;
            },
             async fetchKlineForPeriod(symbol, startTime, endTime) {
                const interval = (endTime - startTime) > (30 * 24 * 60 * 60 * 1000) ? 'D' : '60';
                const url = `${Config.API_BASE_URL}${Config.KLINE_ENDPOINT}?category=linear&symbol=${symbol}&interval=${interval}&start=${startTime}&end=${endTime}&limit=1000`;
                const response = await fetch(url);
                if (!response.ok) return null;
                const data = await response.json();
                return (data.retCode === 0 && data.result.list.length > 0) ? data.result.list : null;
            }
        };

        const Renderer = {
            createCommonControlsHTML(idPrefix) {
                const excludeHTML = idPrefix === 'price' 
                    ? `<div class="pt-6 border-t border-gray-700/60">
                           <label for="exclude-input-${idPrefix}" class="block mb-2 text-sm font-medium text-gray-300 text-center">Exclude tokens (comma-separated)</label>
                           <input type="text" id="exclude-input-${idPrefix}" class="bg-gray-700 border border-gray-600 text-white text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full md:w-2/3 mx-auto p-2.5" value="BTC, ETH, ETHBTC, PAXG, SOL, USDC, USDE, XAUT">
                       </div>` 
                    : '';

                return `
                <div>
                    <label class="block mb-4 text-lg font-semibold text-white text-center">Select Timeframe</label>
                    <div class="flex flex-col sm:flex-row items-center justify-center gap-4 sm:gap-6">
                        <div class="flex items-center gap-1 p-1 bg-gray-900/50 rounded-lg">
                            <button data-hours="1" class="timeframe-btn-${idPrefix} bg-gray-700/50 hover:bg-gray-700 text-gray-300 font-semibold py-2 px-4 rounded-md transition duration-200">1h</button>
                            <button data-hours="4" class="timeframe-btn-${idPrefix} bg-gray-700/50 hover:bg-gray-700 text-gray-300 font-semibold py-2 px-4 rounded-md transition duration-200">4h</button>
                            <button data-hours="24" class="timeframe-btn-${idPrefix} bg-gray-700/50 hover:bg-gray-700 text-gray-300 font-semibold py-2 px-4 rounded-md transition duration-200">24h</button>
                            <button data-hours="168" class="timeframe-btn-${idPrefix} bg-gray-700/50 hover:bg-gray-700 text-gray-300 font-semibold py-2 px-4 rounded-md transition duration-200">7d</button>
                        </div>
                        <div class="text-gray-500 font-medium hidden sm:block">or</div>
                        <div class="flex items-center gap-2">
                             <input type="number" id="custom-time-input-${idPrefix}" class="bg-gray-700 border border-gray-600 text-white text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-24 p-2.5" placeholder="12">
                             <select id="custom-time-unit-${idPrefix}" class="bg-gray-700 border border-gray-600 text-white text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block p-2.5 appearance-none text-center">
                                 <option value="minutes">Minutes</option>
                                 <option value="hours" selected>Hours</option>
                                 <option value="days">Days</option>
                             </select>
                             <button id="custom-time-btn-${idPrefix}" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2.5 px-5 rounded-md transition duration-300 flex items-center justify-center gap-2 min-w-[100px]">
                                <span class="btn-text">Analyze</span>
                                <span class="btn-loader-container"></span>
                             </button>
                        </div>
                    </div>
                </div>
                ${excludeHTML}`;
            },
            createResultsContainerHTML(idPrefix) {
                const keyTokensHTML = idPrefix === 'price' || idPrefix === 'volatility' ? `<div id="key-tokens-container-${idPrefix}" class="mb-6"></div>` : '';
                return `
                <div id="loader-${idPrefix}" class="hidden flex-col items-center justify-center p-10">
                    <div class="loader mb-4"></div>
                    <p class="text-lg text-gray-400 mb-4">Loading data...</p>
                    <div class="w-full bg-gray-700 rounded-full h-2.5"><div id="progress-bar-${idPrefix}" class="bg-blue-600 h-2.5 rounded-full" style="width: 0%"></div></div>
                    <p id="progress-text-${idPrefix}" class="text-sm text-gray-400 mt-2">Fetching symbols...</p>
                </div>
                <div id="error-message-${idPrefix}" class="hidden bg-red-900 border border-red-600 text-red-100 px-4 py-3 rounded-lg relative" role="alert">
                    <strong class="font-bold">Error!</strong>
                    <span class="block sm:inline" id="error-text-${idPrefix}"></span>
                </div>
                <div id="results-dashboard-${idPrefix}" class="hidden">
                    ${keyTokensHTML}
                    <div id="summary-stats-${idPrefix}" class="mb-6"></div>
                    <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                        <div id="top-10-container-${idPrefix}"></div>
                        <div id="bottom-10-container-${idPrefix}"></div>
                    </div>
                </div>`;
            },
        };

        class BaseAnalyzer {
            constructor(id) {
                this.id = id;
                this.isRunning = false;
                this.controlsContainer = document.getElementById(`controls-${id}`);
                this.contentContainer = document.getElementById(`content-area-${id}`);
                this.bindEvents();
            }

            bindEvents() {
                this.controlsContainer.addEventListener('click', (e) => {
                    if (this.isRunning) return;

                    let hours;
                    const buttonTarget = e.target.closest('button');
                    if (!buttonTarget) return;

                    if (buttonTarget.matches(`.timeframe-btn-${this.id}`)) {
                        const allBtns = this.controlsContainer.querySelectorAll(`.timeframe-btn-${this.id}`);
                        allBtns.forEach(b => b.classList.remove('selected'));
                        buttonTarget.classList.add('selected');
                        hours = parseInt(buttonTarget.dataset.hours, 10);
                    } else if (buttonTarget.matches(`#custom-time-btn-${this.id}`)) {
                        const allBtns = this.controlsContainer.querySelectorAll(`.timeframe-btn-${this.id}`);
                        allBtns.forEach(b => b.classList.remove('selected'));
                        const value = parseFloat(this.controlsContainer.querySelector(`#custom-time-input-${this.id}`).value);
                        if (isNaN(value) || value <= 0) {
                            this.getUI().showError("Please enter a valid positive number.");
                            return;
                        }
                        const unit = this.controlsContainer.querySelector(`#custom-time-unit-${this.id}`).value;
                        hours = unit === 'minutes' ? value / 60 : (unit === 'days' ? value * 24 : value);
                    }
                    
                    if (hours !== undefined) {
                        this.runWrapper({ hours });
                    }
                });
            }
            
            getUI() {
                return {
                    showLoader: () => document.getElementById(`loader-${this.id}`).classList.replace('hidden', 'flex'),
                    hideLoader: () => document.getElementById(`loader-${this.id}`).classList.replace('flex', 'hidden'),
                    showError: (message) => {
                        const errorContainer = document.getElementById(`error-message-${this.id}`);
                        errorContainer.querySelector('span').textContent = message;
                        errorContainer.classList.remove('hidden');
                        document.getElementById(`results-dashboard-${this.id}`).classList.add('hidden');
                    },
                    showResults: () => {
                        const dashboard = document.getElementById(`results-dashboard-${this.id}`);
                        dashboard.classList.remove('hidden');
                        dashboard.querySelectorAll('[id*="-container-"], [id*="-stats-"]').forEach((el, index) => {
                             if (el && el.innerHTML.trim() !== '') {
                                 el.classList.add('fade-up');
                                 el.classList.remove('visible');
                                 setTimeout(() => el.classList.add('visible'), index * 100);
                            }
                        });
                    }
                }
            }
            
            getProgress() {
                 const progressBar = document.getElementById(`progress-bar-${this.id}`);
                 const progressText = document.getElementById(`progress-text-${this.id}`);
                 return {
                    update: (current, total, text) => {
                        const percent = total > 0 ? (current / total) * 100 : 0;
                        progressBar.style.width = `${percent}%`;
                        progressText.textContent = text ? text : `Processing ${current} / ${total}...`;
                    }
                }
            }
            
            getExcludedTokens() {
                const input = this.controlsContainer.querySelector(`#exclude-input-${this.id}`);
                return input ? input.value.toUpperCase().split(',').map(t => t.trim()).filter(Boolean) : [];
            }

            setButtonLoading(isLoading) {
                const button = this.controlsContainer.querySelector(`#custom-time-btn-${this.id}`);
                const text = button.querySelector('.btn-text');
                const loaderContainer = button.querySelector('.btn-loader-container');
                if (isLoading) {
                    button.disabled = true;
                    text.style.display = 'none';
                    loaderContainer.innerHTML = '<div class="btn-loader"></div>';
                } else {
                    button.disabled = false;
                    text.style.display = 'inline';
                    loaderContainer.innerHTML = '';
                }
            }
            
            async runWrapper({ hours }) {
                if (isNaN(hours) || this.isRunning) return;
                this.isRunning = true;
                this.setButtonLoading(true);
                this.getUI().showLoader();
                try {
                    const progress = this.getProgress();
                    progress.update(0, 1, "Fetching symbols...");
                    const instruments = await ApiService.fetchInstrumentsInfo();
                    const allSymbols = instruments.map(i => i.symbol);
                    
                    const params = { hours };

                    const allValidResults = await this.analyzeTokens(allSymbols, params);
                    
                    progress.update(allSymbols.length, allSymbols.length, `Processing data...`);
                    if (allValidResults.length === 0) throw new Error(`No data available for the selected period.`);
                    
                    const processedData = this.processResults(allValidResults);
                    
                    this.render(processedData, params);
                    this.getUI().showResults();

                } catch (error) {
                    console.error(`${this.id} Analysis Error:`, error);
                    this.getUI().showError(error.message);
                } finally {
                    this.setButtonLoading(false);
                    this.getUI().hideLoader();
                    this.isRunning = false;
                }
            }

            async analyzeTokens(symbols, params) { throw new Error("analyzeTokens method must be implemented"); }
            processResults(allValidResults) { throw new Error("processResults method must be implemented"); }
            render(data, params) { throw new Error("render method must be implemented"); }
        }

        class PriceAnalyzer extends BaseAnalyzer {
            constructor() { super('price'); }

            async analyzeTokens(allSymbols, { hours }) {
                const progress = this.getProgress();
                const now = new Date();
                const utcNow = Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate(), now.getUTCHours(), now.getUTCMinutes());
                const startTime = utcNow - (hours * 3600 * 1000);
                const klineInterval = hours > 720 ? 'D' : '1';
                
                progress.update(0, 1, 'Fetching current prices...');
                const tickers = await ApiService.fetchAllTickers();
                const tickersMap = new Map(tickers.map(t => [t.symbol, t.lastPrice]));
                
                progress.update(0, allSymbols.length, `Fetching historical prices for ${allSymbols.length} tokens...`);
                
                const processToken = async (symbol) => {
                    const endPriceStr = tickersMap.get(symbol);
                    if (!endPriceStr) return null;

                    const startPriceData = await ApiService.fetchKlineData(symbol, startTime, klineInterval);
                    if (!startPriceData) return null;

                    const startTimestampFromServer = parseInt(startPriceData[0], 10);
                    const tolerance = 24 * 60 * 60 * 1000;
                    if (klineInterval === 'D' && Math.abs(startTimestampFromServer - startTime) > tolerance) {
                        return null;
                    }

                    const startPrice = parseFloat(startPriceData[4]);
                    const endPrice = parseFloat(endPriceStr);
                    if (startPrice === 0) return null;
                    
                    const change = ((endPrice - startPrice) / startPrice) * 100;
                    const pricePrecision = Math.max(2, (startPrice.toString().split('.')[1] || '').length);
                    return { symbol, startPrice: startPrice.toFixed(pricePrecision), endPrice: endPrice.toFixed(pricePrecision), change: parseFloat(change.toFixed(2)) };
                };

                return await Utils.processWithConcurrency(
                    allSymbols,
                    30,
                    processToken,
                    (current, total) => progress.update(current, total)
                );
            }
            
            processResults(allValidResults) {
                const keyTokenData = ['BTCUSDT', 'ETHUSDT', 'SOLUSDT'].map(s => allValidResults.find(r => r.symbol === s)).filter(Boolean);
                const excludedTokens = this.getExcludedTokens();
                const filteredResults = allValidResults.filter(r => !excludedTokens.includes(r.symbol.replace('USDT', '')));
                
                if(filteredResults.length === 0) return { keyTokenData, stats: { count: 0, averageReturn: '0.00', medianReturn: '0.00' }, top10: [], bottom10: [] };

                filteredResults.sort((a, b) => b.change - a.change);
                const changes = filteredResults.map(r => r.change);
                const sum = changes.reduce((a, v) => a + v, 0);
                const average = sum / changes.length;
                const sortedChanges = [...changes].sort((a, b) => a - b);
                const midIndex = Math.floor(changes.length / 2);
                const median = changes.length % 2 === 0 ? (sortedChanges[midIndex - 1] + sortedChanges[midIndex]) / 2 : sortedChanges[midIndex];
                const stats = { count: filteredResults.length, averageReturn: average.toFixed(2), medianReturn: median.toFixed(2) };

                const top10 = filteredResults.slice(0, 10);
                const bottom10 = filteredResults.slice(-10).reverse();
                return { keyTokenData, stats, top10, bottom10 };
            }
            
            render(data, {hours}) {
                const { keyTokenData, stats, top10, bottom10 } = data;
                
                const keyContainer = document.getElementById('key-tokens-container-price');
                if (!keyTokenData || keyTokenData.length === 0) { keyContainer.innerHTML = ''; }
                else {
                    const cardsHTML = keyTokenData.map(item => {
                        const color = item.change >= 0 ? 'text-green-500' : 'text-red-500';
                        return `<div class="bg-gray-700 p-4 rounded-lg flex justify-between items-center shadow-lg transition-transform duration-200 hover:scale-105"><div><p class="text-lg font-bold text-white">${item.symbol.replace('USDT','')}</p><p class="text-xs text-gray-400">${item.startPrice} → ${item.endPrice}</p></div><p class="text-xl font-bold ${color}">${item.change >= 0 ? '+' : ''}${item.change}%</p></div>`;
                    }).join('');
                    keyContainer.innerHTML = `<div class="grid grid-cols-1 md:grid-cols-3 gap-4">${cardsHTML}</div>`;
                }
                
                 const avgColor = stats.averageReturn >= 0 ? 'text-green-500' : 'text-red-500';
                 const medColor = stats.medianReturn >= 0 ? 'text-green-500' : 'text-red-500';
                 document.getElementById('summary-stats-price').innerHTML = `<div class="bg-gray-800 p-6 rounded-lg shadow-lg"><h3 class="text-xl font-semibold text-white mb-4">Market Summary for the last ${Utils.formatTimeframe(hours)} (Exclusions Applied)</h3><div class="grid grid-cols-1 sm:grid-cols-3 gap-4 text-center"><div><p class="text-sm text-gray-400">Analyzed Tokens</p><p class="text-2xl font-bold text-white">${stats.count}</p></div><div><p class="text-sm text-gray-400">Average Return</p><p class="text-2xl font-bold ${avgColor}">${stats.averageReturn}%</p></div><div><p class="text-sm text-gray-400">Median Return</p><p class="text-2xl font-bold ${medColor}">${stats.medianReturn}%</p></div></div></div>`;

                const createTableHTML = (title, data) => {
                     if (data.length === 0) return `<div class="bg-gray-800 rounded-lg shadow-lg p-4 text-center text-gray-500">${title}<br><br>No data to display.</div>`;
                     const tableRows = data.map(item => `<tr class="bg-gray-800 border-b border-gray-700 hover:bg-gray-700/50 transition-colors duration-200"><th scope="row" class="px-4 py-3 font-medium text-white whitespace-nowrap"><div>${item.symbol}</div><div class="text-xs text-gray-500">${item.startPrice} → ${item.endPrice}</div></th><td class="px-4 py-3 text-right font-bold ${item.change >= 0 ? 'text-green-500' : 'text-red-500'}">${item.change >= 0 ? '+' : ''}${item.change}%</td></tr>`).join('');
                     return `<div class="bg-gray-800 rounded-lg shadow-lg overflow-hidden"><table class="w-full text-sm text-left text-gray-400"><caption class="p-4 text-lg font-semibold text-left text-white bg-gray-700/50">${title}</caption><thead class="text-xs text-gray-300 uppercase bg-gray-700"><tr><th scope="col" class="px-4 py-2">Symbol</th><th scope="col" class="px-4 py-2 text-right">Change</th></tr></thead><tbody>${tableRows}</tbody></table></div>`;
                };

                document.getElementById('top-10-container-price').innerHTML = createTableHTML('🚀 Top 10 Gainers', top10);
                document.getElementById('bottom-10-container-price').innerHTML = createTableHTML('📉 Top 10 Losers', bottom10);
            }
        }

        class VolatilityAnalyzer extends BaseAnalyzer {
            constructor() { super('volatility'); }
            
            async analyzeTokens(allSymbols, { hours }) {
                const progress = this.getProgress();
                const now = new Date();
                const endTime = Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate(), now.getUTCHours(), now.getUTCMinutes());
                const startTime = endTime - (hours * 3600 * 1000);

                const processToken = async (symbol) => {
                    const klines = await ApiService.fetchKlineForPeriod(symbol, startTime, endTime);
                    if (!klines || klines.length === 0) return null;
                    
                    const firstCandleTimestamp = parseInt(klines[klines.length - 1][0], 10);
                    const tolerance = 24 * 60 * 60 * 1000;
                    if (Math.abs(firstCandleTimestamp - startTime) > tolerance) {
                        return null; 
                    }

                    let high = 0;
                    let low = Infinity;
                    klines.forEach(candle => {
                        const h = parseFloat(candle[2]);
                        const l = parseFloat(candle[3]);
                        if (h > high) high = h;
                        if (l < low) low = l;
                    });

                    if (low === 0 || low === Infinity) return null;
                    const volatility = ((high - low) / low) * 100;
                    return { symbol, high, low, volatility: parseFloat(volatility.toFixed(2)) };
                };
                
                return await Utils.processWithConcurrency(
                    allSymbols,
                    30,
                    processToken,
                    (current, total) => progress.update(current, total)
                );
            }
            
            processResults(allValidResults) {
                allValidResults.sort((a, b) => b.volatility - a.volatility);
                const mostVolatile = allValidResults.slice(0, 10);
                const leastVolatile = [...allValidResults].sort((a, b) => a.volatility - b.volatility).slice(0, 10);
                const keyTokenData = ['BTCUSDT', 'ETHUSDT', 'SOLUSDT'].map(s => allValidResults.find(r => r.symbol === s)).filter(Boolean);
                const stats = { count: allValidResults.length };
                return { mostVolatile, leastVolatile, stats, keyTokenData };
            }
            
            render(data, {hours}) {
                const { mostVolatile, leastVolatile, stats, keyTokenData } = data;
                
                const keyContainer = document.getElementById('key-tokens-container-volatility');
                if (!keyTokenData || keyTokenData.length === 0) { keyContainer.innerHTML = ''; }
                else {
                    const cardsHTML = keyTokenData.map(item => {
                        return `<div class="bg-gray-800 p-4 rounded-lg flex justify-between items-center shadow-lg transition-transform duration-200 hover:scale-105"><div><p class="text-lg font-bold text-white">${item.symbol.replace('USDT','')}</p><p class="text-xs text-gray-400">${item.low.toFixed(4)} (L) ↔ ${item.high.toFixed(4)} (H)</p></div><p class="text-xl font-bold text-blue-400">${item.volatility}%</p></div>`;
                    }).join('');
                    keyContainer.innerHTML = `<div class="grid grid-cols-1 md:grid-cols-3 gap-4">${cardsHTML}</div>`;
                }
                
                document.getElementById('summary-stats-volatility').innerHTML = `<div class="bg-gray-800 p-6 rounded-lg shadow-lg"><h3 class="text-xl font-semibold text-white mb-4">Market Summary for the last ${Utils.formatTimeframe(hours)}</h3><div class="grid grid-cols-1"><p class="text-center text-2xl font-bold text-white">${stats.count} <span class="text-sm text-gray-400 font-normal">Analyzed Tokens</span></p></div></div>`;

                const createTableHTML = (title, data) => {
                     if (data.length === 0) return `<div class="bg-gray-800 rounded-lg shadow-lg p-4 text-center text-gray-500">${title}<br><br>No data to display.</div>`;
                     const tableRows = data.map(item => `<tr class="bg-gray-800 border-b border-gray-700 hover:bg-gray-700/50 transition-colors duration-200"><th scope="row" class="px-4 py-3 font-medium text-white whitespace-nowrap"><div>${item.symbol}</div><div class="text-xs text-gray-500">${item.low.toFixed(4)} (L) → ${item.high.toFixed(4)} (H)</div></th><td class="px-4 py-3 text-right font-bold text-blue-400">${item.volatility}%</td></tr>`).join('');
                     return `<div class="bg-gray-800 rounded-lg shadow-lg overflow-hidden"><table class="w-full text-sm text-left text-gray-400"><caption class="p-4 text-lg font-semibold text-left text-white bg-gray-700/50">${title}</caption><thead class="text-xs text-gray-300 uppercase bg-gray-700"><tr><th scope="col" class="px-4 py-2">Symbol</th><th scope="col" class="px-4 py-2 text-right">Volatility</th></tr></thead><tbody>${tableRows}</tbody></table></div>`;
                };

                document.getElementById('top-10-container-volatility').innerHTML = createTableHTML('🔥 Top 10 Most Volatile', mostVolatile);
                document.getElementById('bottom-10-container-volatility').innerHTML = createTableHTML('❄️ Top 10 Least Volatile', leastVolatile);
            }
        }
        
        const App = {
            analyzers: {},
            pages: {},
            navButtons: {},

            init() {
                this.pages = {
                    price: document.getElementById('price-analyzer-page'),
                    volatility: document.getElementById('volatility-analyzer-page')
                };
                this.navButtons = {
                    price: document.getElementById('nav-price-analyzer'),
                    volatility: document.getElementById('nav-volatility-analyzer')
                };

                document.getElementById('controls-price').innerHTML = Renderer.createCommonControlsHTML('price');
                document.getElementById('content-area-price').innerHTML = Renderer.createResultsContainerHTML('price');
                document.getElementById('controls-volatility').innerHTML = Renderer.createCommonControlsHTML('volatility');
                document.getElementById('content-area-volatility').innerHTML = Renderer.createResultsContainerHTML('volatility');

                this.analyzers.price = new PriceAnalyzer();
                this.analyzers.volatility = new VolatilityAnalyzer();
                this.setupNavigation();
            },
            setupNavigation() {
                Object.keys(this.navButtons).forEach(key => {
                    this.navButtons[key].addEventListener('click', () => this.showPage(key));
                });
            },
            showPage(pageKey) {
                Object.keys(this.pages).forEach(key => {
                    this.pages[key].classList.toggle('hidden', key !== pageKey);
                    this.navButtons[key].classList.toggle('selected', key === pageKey);
                });
            }
        };

        App.init();

    </script>
</body>
</html>
